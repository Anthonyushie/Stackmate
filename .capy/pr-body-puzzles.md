## Summary

Add a 50-puzzle database and a TypeScript API for retrieving and validating puzzles with chess.js, plus a SHA-256 solution hasher suitable for on-chain storage.

## What’s included

1. `src/data/puzzles.json`
   - 50 puzzles across three difficulty buckets: `beginner`, `intermediate`, `expert`
   - Each puzzle has: `id`, `fen`, `solution` (SAN sequence), `description`, `difficulty`
   - Solutions are full SAN move sequences (both sides) that are legal from the provided FEN

2. `src/lib/puzzles-db.ts`
   - `getPuzzlesByDifficulty(difficulty)` → list of puzzles by bucket
   - `getPuzzleById(id)` → single puzzle lookup
   - `getRandomPuzzle(difficulty)` → random puzzle from a bucket
   - `validateSolution(puzzleId, moves)` → verifies that the SAN move list is legal from the puzzle FEN using `chess.js`
   - `hashSolution(moves)` → SHA-256 hash of the normalized move sequence (hex string, `0x`-prefixed, 32 bytes) for storing in smart contracts

## Implementation details

- Validation uses `chess.js` with `sloppy: true` to accept SAN/ambiguous SAN inputs robustly
- `hashSolution` uses `window.crypto.subtle` when available, with a Node `crypto` fallback
- Puzzles include well-known opening sequences and a couple of quick mates for variety

## Notes

- Consumers should pass SAN moves to `validateSolution` (e.g., `['e4','e5','Qh5','Nc6','Bc4','Nf6','Qxf7#']`).
- The hasher uses the joined SAN sequence (space-delimited) as input; callers should use the same normalization to reproduce hashes.

## Next steps

- Add more tactical/endgame compositions and tag metadata (theme, mate-in-N)
- Add unit tests for validation and hashing
- Optionally add a UI to browse and attempt puzzles in-app


₍ᐢ•(ܫ)•ᐢ₎ Generated by [Capy](https://capy.ai) ([view task](https://capy.ai/project/d0cfbf19-1464-4f41-ad4d-70ad1fe580a6/task/02475219-f0e0-4b23-ab01-ca9473763120))